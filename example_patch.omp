; OM File Header - Saved 2023/10/30 15:02:26
; (7.02 :patc (om-make-point 263 129) (om-make-point 50 50) (om-make-point 1272 603) "" 183 0 "2023/06/26 11:02:53" "2023/10/30 15:02:26")
; End File Header
(in-package :om)(load-lib-for (quote nil))(setf *om-current-persistent* (om-load-patch1 "Big example" (quote ((let ((box (om-load-boxcall (quote lispfun) "MINOR" (quote |gilf|::minor) (quote nil) (om-make-point 189 52) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "MAJOR" (quote |gilf|::major) (quote nil) (om-make-point 232 53) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 8" (quote list) (quote nil) (om-make-point 147 59) (om-make-point 27 30) 0 "0" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "NEW-4-VOICE" (quote |gilf|::new-4-voice) (quote ((om-load-inputfun (quote input-funbox) "KEY" "KEY" nil) (om-load-inputfun (quote input-funbox) "MODE" "MODE" nil) (om-load-inputfun (quote input-funbox) "CHORD-DEGREES" "CHORD-DEGREES" nil) (om-load-inputfun (quote input-funbox) "CHORD-STATES" "CHORD-STATES" nil))) (om-make-point 228 129) nil (list nil) "x" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "BAB" (quote |gilf|::bab) (quote nil) (om-make-point 1114 19) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-editor-box1 "VOICE" (quote voice) (quote ((om-load-inputfun (quote input-funbox) "object" "self" nil) (om-load-inputfun (quote input-funbox) "a list representing a rhythm tree" "tree" (list (quote ?) (list (list (list 4 4) (list 1 1 1 1))))) (om-load-inputfun (quote input-funbox) "a chord object, a list of chords, a list of midics, a list of lists of midics..." "chords" (list (let ((thechord (make-instance (quote chord) :lmidic (quote (6000)) :ldur (quote (1000)) :lvel (quote (100)) :loffset (quote (0)) :lchan (quote (1))))) (load-port-info thechord (quote (0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord))) (om-load-inputfun (quote input-funbox) "frequency of the quarter-note (default 60/mn)" "tempo" 60) (om-load-inputfun (quote input-funbox) "overlapping percentage between every successive chords, calculated from the second chord's duration" "legato" 100) (om-load-inputfun (quote input-funbox) "sub lists (one sub list per chord) indicating notes to be tied to notes of the same value, in a next chord" "ties" nil))) (om-make-point 299 299) (om-make-point 726 196) (let ((newobj (when (find-class (quote voice) nil) (make-instance (quote voice) :tree (quote (9 (((4 4) (4)) ((4 4) (4)) ((4 4) (4)) ((4 4) (4)) ((4 4) (4)) ((4 4) (4)) ((4 4) (4)) ((4 4) (4)) ((4 4) (4))))) :chords (load-obj-list-from-save (quote ((let ((thechord (make-instance (quote chord) :lmidic (quote (4800 6300 6700 7200)) :ldur (quote (2000 2000 2000 2000)) :lvel (quote (100 100 100 100)) :loffset (quote (0 0 0 0)) :lchan (quote (1 1 1 1))))) (load-port-info thechord (quote (0 0 0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5300 6500 6800 7200)) :ldur (quote (2000 2000 2000 2000)) :lvel (quote (100 100 100 100)) :loffset (quote (0 0 0 0)) :lchan (quote (1 1 1 1))))) (load-port-info thechord (quote (0 0 0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5000 6500 7100 7400)) :ldur (quote (2000 2000 2000 2000)) :lvel (quote (100 100 100 100)) :loffset (quote (0 0 0 0)) :lchan (quote (1 1 1 1))))) (load-port-info thechord (quote (0 0 0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5100 6300 7000 7900)) :ldur (quote (2000 2000 2000 2000)) :lvel (quote (100 100 100 100)) :loffset (quote (0 0 0 0)) :lchan (quote (1 1 1 1))))) (load-port-info thechord (quote (0 0 0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5600 6300 7200 8000)) :ldur (quote (2000 2000 2000 2000)) :lvel (quote (100 100 100 100)) :loffset (quote (0 0 0 0)) :lchan (quote (1 1 1 1))))) (load-port-info thechord (quote (0 0 0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5300 6500 7400 8000)) :ldur (quote (2000 2000 2000 2000)) :lvel (quote (100 100 100 100)) :loffset (quote (0 0 0 0)) :lchan (quote (1 1 1 1))))) (load-port-info thechord (quote (0 0 0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5500 6300 7200 7900)) :ldur (quote (2000 2000 2000 2000)) :lvel (quote (100 100 100 100)) :loffset (quote (0 0 0 0)) :lchan (quote (1 1 1 1))))) (load-port-info thechord (quote (0 0 0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (5500 6200 7100 7900)) :ldur (quote (2000 2000 2000 2000)) :lvel (quote (100 100 100 100)) :loffset (quote (0 0 0 0)) :lchan (quote (1 1 1 1))))) (load-port-info thechord (quote (0 0 0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord) (let ((thechord (make-instance (quote chord) :lmidic (quote (6000 6300 7200 7900)) :ldur (quote (2000 2000 2000 2000)) :lvel (quote (100 100 100 100)) :loffset (quote (0 0 0 0)) :lchan (quote (1 1 1 1))))) (load-port-info thechord (quote (0 0 0 0))) (init-mus-color thechord (quote nil)) (set-extra-pairs thechord (quote nil)) (set-tonalite thechord nil) thechord)))) :tempo (quote ((1/4 120) nil)) :legato 100 :ties (quote (nil nil nil nil nil nil nil nil nil)))))) (load-port-info newobj (quote nil)) (init-mus-color newobj (quote nil)) (set-extra-pairs newobj (quote nil)) (set-patch-pairs newobj (quote ((nil (om-load-patch-abs1 "patch" (quote nil) (quote nil) 7.02 nil "" (om-make-point 200 200) (om-make-point 400 500)))))) (set-name newobj nil) (set-tonalite newobj nil) newobj) "x" nil (pairlis (quote (approx fontsize staff cmnpref deltapict outport inport player zoom notechancolor? grillestep mode winsize winpos score-mode obj-mode cursor-mode show-stems scale)) (list 2 24 (quote gf) (let ((newobj (make-instance (quote edition-values)))) (setf (paper-size newobj) (om-make-point 600 800)) (setf (top-margin newobj) 2) (setf (left-margin newobj) 1) (setf (right-margin newobj) 1) (setf (bottom-margin newobj) 1) (setf (orientation newobj) nil) (setf (scale newobj) nil) (setf (system-space newobj) (quote (1))) (setf (system-color newobj) (quote nil)) (setf (line-space newobj) 1) (setf (title newobj) nil) (setf (show-title? newobj) nil) (setf (show-page? newobj) nil) (setf (sheet-id newobj) nil) (setf (page-mode newobj) nil) newobj) (om-make-point 0 0) nil nil (quote :midi-player) 1 nil 1000 0 (om-make-point 1092 421) (om-make-point 175 221) 0 0 (quote :normal) (quote t) nil)) t nil nil nil (quote nil)))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 7" (quote list) (quote nil) (om-make-point 720 197) (om-make-point 31 30) 120 "120" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM-" (quote om-) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 285 42) (om-make-point 19 35) nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 6" (quote list) (quote nil) (om-make-point 330 14) (om-make-point 17 30) 1 "1" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 5" (quote list) (quote nil) (om-make-point 590 139) (om-make-point 38 30) (list 4 4) "(4 4)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "MKTREE" (quote mktree) (quote ((om-load-inputfun (quote input-funbox) "list of integer ratios" "RHYTHM" (list 1/4 1/4 1/4 1/4)) (om-load-inputfun (quote input-funbox) "list of time signatures" "TIMESIGNS" (list 4 4)))) (om-make-point 531 184) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 4" (quote list) (quote nil) (om-make-point 457 141) (om-make-point 124 30) (list 1 1 1 1 1 1 1 1 1) "(1 1 1 1 1 1 1 1 1)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SOLUTION-TO-INT-ARRAY" (quote |gilf|::solution-to-int-array) (quote ((om-load-inputfun (quote input-funbox) "SP" "SP" nil))) (om-make-point 924 132) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list" (quote list) (quote nil) (om-make-point 887 180) (om-make-point 31 30) 100 "100" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote genfun) "OM*" (quote om*) (quote ((om-load-inputfun (quote input-funbox) "number or list" "ARG1" 0) (om-load-inputfun (quote input-funbox) "number or list" "ARG2" 0))) (om-make-point 792 201) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "SOLUTION-TO-CHORD-LIST" (quote |gilf|::solution-to-chord-list) (quote ((om-load-inputfun (quote input-funbox) "SP" "SP" nil))) (om-make-point 808 101) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "RETURN-NEXT-SOLUTION-SPACE" (quote |gilf|::return-next-solution-space) (quote ((om-load-inputfun (quote input-funbox) "SOLVER" "SOLVER" nil))) (om-make-point 1068 122) nil nil nil nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote lispfun) "CREATE-SOLVER" (quote |gilf|::create-solver) (quote ((om-load-inputfun (quote input-funbox) "SP" "SP" nil) (om-load-inputfun (quote input-funbox) "SOLVER-TYPE" "SOLVER-TYPE" nil))) (om-make-point 1044 82) nil (list nil) "x" nil 1))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 3" (quote list) (quote nil) (om-make-point 339 51) (om-make-point 124 30) (list 0 0 1 0 0 1 2 0 0) "(0 0 1 0 0 1 2 0 0)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box) (let ((box (om-load-boxcall (quote bastype) "list 2" (quote list) (quote nil) (om-make-point 189 8) (om-make-point 124 30) (list 1 4 7 3 6 2 1 5 1) "(1 4 7 3 6 2 1 5 1)" nil))) (when (fboundp (quote set-active)) (set-active box nil)) box))) (quote ((2 0 3 0 nil 0) (0 0 3 1 nil 0) (7 0 3 2 nil 0) (18 0 3 3 nil 0) (10 0 5 1 nil 0) (14 0 5 2 nil 0) (6 0 5 3 nil 0) (19 0 7 0 nil 0) (8 0 7 1 nil 0) (11 0 10 0 nil 0) (9 0 10 1 nil 0) (16 0 12 0 nil 0) (15 0 14 0 nil 0) (13 0 14 1 nil 0) (12 0 15 0 nil 0) (17 0 16 0 nil 0) (3 0 17 0 nil 0) (4 0 17 1 nil 0))) nil 7.02))